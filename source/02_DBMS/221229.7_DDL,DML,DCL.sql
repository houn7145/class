-- [ VII ] DDL, DCL, DML
-- SQL = DDL(테이블 생성, 테이블 삭제, 테이블 구조변경, 테이블 모든 데이터 제거) + 
--       DML(SELECT, INSERT, UPDATE, DELETE) + 
--       DCL(사용자계정 생성, 사용자 권한 부여, 권한 박탈, 사용자계정 삭제, 트랜젝션 명령어)

-- ★ ★ ★ DDL ★ ★ ★
-- 1. 테이블 생성(CREATE TABLE 테이블명) : 테이블 구조 정의
CREATE TABLE BOOK (
    BOOKID NUMBER(4), -- BOOKID 필드의 타입은 숫자 4자리
    BOOKNAME VARCHAR2(50), -- BOOKNAME 필드의 타입은 문자 50바이트
    PUBLISHER VARCHAR2(50), -- PUBLSHER 필드의 타입은 문자 50바이트
    RDATE     DATE,         -- RDATE 필드의 타입은 DATE형
    PRICE     NUMBER(8, 2), -- PRICE 필드의 타입은 숫자 (전체 8자리, 소수점 2자리 / 소수점 앞 6자리)
    PRIMARY KEY(BOOKID) -- 제약조건 : BOOKID 필드가 주키 : NOT NULL, UNIQUE
); 
SELECT * FROM BOOK;
DESC BOOK;

DROP TABLE BOOK; -- 테이블 삭제

CREATE TABLE BOOK (
    BID         NUMBER(4) PRIMARY KEY,
    BNAME       VARCHAR2(20),
    PUBLISHER   VARCHAR2(20),
    RDATE       DATE,
    PRICE       NUMBER(8));

SELECT * FROM BOOK;
DESC BOOK;

    -- ex. EMP와 유사한 EMP01 테이블 : EMPNO(숫자 4자리), ENAME(문자 10바이트), SAL(숫자 7자리, 2자리)
CREATE TABLE EMP01 (
    EMPNO   NUMBER(4),
    ENAME   VARCHAR2(10),
    SAL     NUMBER(7,2)   
);
SELECT * FROM EMP01;
DESC EMP01;

    -- ex. DEPT01 테이블 : DEPTNO(숫자 2자리 : PK), DNAME(문자 14바이트), LOC(문자 13바이트)
CREATE TABLE DEPT01 (
    DEPTNO  NUMBER(2) PRIMARY KEY,
    DNAME   VARCHAR2(14),
    LOC     VARCHAR2(13)
);
SELECT * FROM DEPT01;
DESC DEPT01;

-- 서브쿼리를 이용한 테이블 생성
CREATE TABLE EMP02
    AS
    SELECT * FROM EMP; -- 서브쿼리 결과로 EMP02 테이블 생성 후 데이터 삽입(제약조건 미포함)
SELECT * FROM EMP02;
DESC EMP02;

    -- EMP03 : EMP 테이블에서 EMPNO, ENAME, DETPNO를 추출한 데이터 삽입
CREATE TABLE EMP03
    AS
    SELECT EMPNO, ENAME, DEPTNO FROM EMP;
SELECT * FROM EMP03;
DESC EMP03;

    -- EMP04 : EMP 테이블에서 10번 부서만 추출한 데이터 삽입
CREATE TABLE EMP04
    AS
    SELECT * FROM EMP WHERE DEPTNO = 10;
SELECT * FROM EMP04;
DESC EMP04;

    -- EMP05 : EMP 테이블 구조만 추출(데이터는 추출 X)
CREATE TABLE EMP05
    AS
    SELECT * FROM EMP WHERE 0=1;
SELECT * FROM EMP05;
DESC EMP05;

SELECT ROWNUM, EMPNO, ENAME, JOB FROM EMP; -- 테이블에서 행의 논리적 순서(읽어들인 순서)

-- 2. 테이블 구조 변경 (ALTER TABLE 테이블명 ADD, MODIFY, DROP ~)
-- (!) 필드 추가(ADD)
SELECT * FROM EMP03; -- EMPNO(수4), ENAME(문10), DEPTNO(수2)
ALTER TABLE EMP03 ADD (JOB VARCHAR2(20), SAL NUMBER(7, 2));
SELECT * FROM EMP03; -- 필드 추가시 데이터는 NULL
ALTER TABLE EMP03 ADD (COMM NUMBER(7, 2));

-- (2) 필드 수정(MODIFY)
SELECT * FROM EMP03; -- EMPNO(수4), ENAME(문10), DEPTNO(수2), JOB, SAL, COMM은 NULL
ALTER TABLE EMP03 MODIFY (EMPNO VARCHAR2(5)); -- 숫자 데이터가 들어있으므로 숫자로만 변경 가능
ALTER TABLE EMP03 MODIFY (EMPNO NUMBER(5));
ALTER TABLE EMP03 MODIFY (EMPNO NUMBER(4)); -- 숫자 데이터는 늘리는것만 가능 (줄이는건 불가능)
ALTER TABLE EMP03 MODIFY (SAL VARCHAR2(10)); -- 데이터가 없으면 마음대로 수정 가능
ALTER TABLE EMP03 MODIFY (ENAME VARCHAR2(20)); -- 문자 데이터는 늘리거나 줄이거나 가능
DESC EMP03;
SELECT * FROM EMP03;
ALTER TABLE EMP03 MODIFY (ENAME VARCHAR2(6)); -- 가능
ALTER TABLE EMP03 MODIFY (ENAME VARCHAR2(5)); -- 불가능

-- (3) 필드 삭제(DROP)
ALTER TABLE EMP03 DROP COLUMN JOB; -- NULL인 필드 삭제(NULL이 아닌 필드는 데이터까지 삭제)
SELECT * FROM EMP03;
ALTER TABLE EMP03 DROP COLUMN DEPTNO;
-- 논리적으로 특정 필드에 접근하지 못하도록(낮)
ALTER TABLE EMP03 SET UNUSED (COMM);
SELECT * FROM EMP03;
-- 논리적으로 접근하지 못했던 필드 삭제(새벽)
ALTER TABLE EMP03 DROP UNUSED COLUMNS;

-- 3. 테이블 삭제(DROP TABLE 테이블명)
DROP TABLE EMP01;
SELECT * FROM EMP01;
DROP TABLE DEPT; -- EMP 테이블에서 DEPT 테이블을 참조하는 경우 EMP 테이블을 삭제한 후 DEPT 테이블 삭제

-- 4. 테이블의 모든 행을 제거(TRUNCATE TABLE 테이블명) 
SELECT * FROM EMP03;
TRUNCATE TABLE EMP03; -- ROLLBACK 불가능
SELECT * FROM EMP03;

-- 5. 테이블명 변경(RENAME 테이블명 TO 바꿀 테이블명)
SELECT * FROM EMP02;
RENAME EMP02 TO EMP2;
SELECT * FROM EMP2;

-- 6. 데이터 딕셔너리(접근불가) VS. 데이터딕셔너리 뷰(접근용)
-- 종류
    -- 1. USER_XXX : 현 계정이 소유하고 있는 객체(테이블, 제약조건, 뷰, 인덱스)
        -- USER_TABLES, USER_CONSTRAINTS, USER_INDEXES, USER_VIEWS
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_VIEWS;

    -- 2. ALL_XXX : 현 계정에서 접근 가능한 객체(테이블, 제약조건, 뷰, 인덱스)
        -- ALL_TABLES, ALL_CONSTRAINTS, ALL_INDEXES, ALL_VIEWS
SELECT * FROM ALL_TABLES; 
SELECT * FROM ALL_VIEWS;

    -- 3. DBA_XXX : DBA권한에서만 접근 가능. DBMS의 모든 객체
        -- DBA_TABLES, DBA_CONSTRAINTS, DBA_INDEXES, DBA_VIEWS
SELECT * FROM DBA_TABLES;

-- ★ ★ ★ DML ★ ★ ★
-- 1. INSERT INTO 테이블명 VALUES (값1, 값2, 값3...)
--    INSERT INTO 테이블명 (필드명1, 필드명2,...) VALUES (값1, 값2,...);
SELECT * FROM DEPT01;
ROLLBACK;
INSERT INTO DEPT01 VALUES (50, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT01 VALUES (60, 'SALES', NULL); -- 명시적으로 NULL 추가
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (70, 'RESEARCH', '서대문');
INSERT INTO DEPT01 (LOC, DEPTNO, DNAME) VALUES ('마포', 80, 'IT');
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (90, 'OPERATION'); -- 묵시적으로 NULL 추가
SELECT * FROM DEPT01;

-- 서브쿼리를 이용한 INSERT
    -- ex. DEPT 테이블에서 10~30번 부서를 DEPT01 테이블로
INSERT INTO DEPT01 SELECT * FROM DEPT WHERE DEPTNO < 40;

    -- ex. BOOK (BID는 11, BNAME은 '스포츠의학', 출판사는 '한솔출판', 출판일은 오늘, 가격은 90000)
SELECT * FROM BOOK;
INSERT INTO BOOK VALUES (11, '스포츠의학', '한솔출판', SYSDATE, 90000);

-- 트랜젝션 명령어 (DML명령어에서만 적용)
    -- 트랜젝션은 데이터 처리의 한 단위. DML 명령어들이 실행됨과 동시에 트랜젝션이 진행.
COMMIT; -- 현 트랜젝션의 작업을 DB에 반영
INSERT INTO BOOK VALUES (12, '스포츠의학', '한솔출판', SYSDATE, 90000);
SELECT * FROM BOOK;
ROLLBACK; -- 현 트랜젝션의 작업을 취소

-- 연습문제
DROP TABLE SAM01;
CREATE TABLE SAM01 (
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    SAL NUMBER(7,2)
);

ALTER TABLE SAM01 MODIFY (ENAME VARCHAR2(10));

INSERT INTO SAM01 VALUES (1000, 'APPLE', 'POLICE', 10000);
INSERT INTO SAM01 VALUES (1010, 'BANANA', 'NURSE', 15000);
INSERT INTO SAM01 VALUES (1020, 'ORANGE', 'DOCTOR', 25000);
INSERT INTO SAM01 (EMPNO, ENAME, SAL) VALUES (1030, 'VERY', 25000);
INSERT INTO SAM01 (EMPNO, ENAME, SAL) VALUES (1040, 'CAT', 2000);
INSERT INTO SAM01 SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 10;

SELECT * FROM SAM01;
COMMIT;
-- 2. UPDATE 테이블명 SET 필드명1 = 값1 WHERE 조건
SELECT * FROM EMP01;
CREATE TABLE EMP01 AS SELECT * FROM EMP;

    -- ex. 부서번호를 30으로 수정
UPDATE EMP01 SET DEPTNO = 30;
ROLLBACK;
SELECT * FROM EMP01;

    -- ex. 모든 직원(EMP01)의 급여를 10% 인상
UPDATE EMP01 SET SAL = SAL*1.1;
SELECT * FROM EMP01;

    -- ex. 10번 부서 직원의 입사일을 오늘로 수정하고, 부서번호를 30으로 수정
UPDATE EMP01 SET HIREDATE = SYSDATE WHERE DEPTNO = 10;
UPDATE EMP01 SET DEPTNO = 30 WHERE DEPTNO = 10;

    -- ex. SAL이 3000 이상인 사원만 급여를 10% 인상
UPDATE EMP01 SET SAL = SAL*1.1 WHERE SAL >= 3000;

    -- ex. DALLAS에 근무하는 직원의 급여를 1000$ 인상
UPDATE EMP01 SET SAL = SAL+1000 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');
SELECT * FROM EMP01;

    -- ex. SCOTT의 부서번호를 20으로, JOB는 MANAGER로, SAL과 COMM은 500씩 인상, 상사는 KING
UPDATE EMP01 
    SET DEPTNO = 20, JOB = 'MANAGER', SAL = SAL+500, COMM = NVL(COMM, 0)+500, MGR = (SELECT EMPNO FROM EMP WHERE ENAME = 'KING') 
    WHERE ENAME = 'SCOTT';
    
    -- ex. DEPT01 테이블에서 60번 부서의 지역명을 20번 부서의 지역명으로 수정
SELECT * FROM DEPT01;
UPDATE DEPT01 
    SET LOC = (SELECT LOC FROM DEPT01 WHERE DEPTNO = 20) 
    WHERE DEPTNO = 60;

    -- ex. EMP01 테이블에서 모든 사원의 급여와 입사일을 KING의 급여와 입사일로 수정
SELECT SAL FROM EMP WHERE ENAME = 'KING';
SELECT HIREDATE FROM EMP WHERE ENAME = 'KING';
UPDATE EMP01 
    SET SAL = (SELECT SAL FROM EMP WHERE ENAME = 'KING'), 
        HIREDATE = (SELECT HIREDATE FROM EMP WHERE ENAME = 'KING');

-- 3. DELETE FROM 테이블명 WHERE 조건
SELECT * FROM EMP01;
DELETE FROM EMP01;

    -- ex. EMP01 테이블에서 30번 부서 직원만 삭제
DELETE FROM EMP01 WHERE DEPTNO = 30;

    -- ex. EMP01 테이블에서 'FORD' 사원 퇴사
DELETE FROM EMP01 WHERE ENAME = 'FORD';

    -- ex. SAM01 테이블에서 JOB이 정해지지 않은 사원을 삭제
SELECT * FROM SAM01;
DELETE FROM SAM01 WHERE JOB IS NULL;

    -- ex. EMP01 테이블에서 부서명이 SALES인 사원을 삭제
DELETE FROM EMP01 WHERE DEPTNO =(SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');

    -- ex. EMP01 테이블에서 부서명이 RESEARCH인 사원을 삭제
DELETE FROM EMP01 WHERE DEPTNO =(SELECT DEPTNO FROM DEPT WHERE DNAME = 'RESEARCH');
COMMIT;

-- ★ 연습문제
CREATE TABLE MY_DATA (
    ID NUMBER(4) PRIMARY KEY,
    NAME VARCHAR2(10),
    USERID VARCHAR2(30),
    SALARY NUMBER(10, 2)
);
SELECT * FROM MY_DATA;
INSERT INTO MY_DATA VALUES(1, 'Scott', 'sscott', 10000);
INSERT INTO MY_DATA VALUES(2, 'Ford', 'fford', 13000);
INSERT INTO MY_DATA VALUES(3, 'Patel', 'ppatel', 33000);
INSERT INTO MY_DATA VALUES(4, 'Report', 'rreport', 23500);
INSERT INTO MY_DATA VALUES(5, 'Good', 'ggood', 44450);
SELECT * FROM MY_DATA;

SELECT TO_CHAR(SALARY, '99,999.99')FROM MY_DATA;
COMMIT;
UPDATE MY_DATA SET SALARY = 65000 WHERE ID = 3;
COMMIT;
DELETE FROM MY_DATA WHERE NAME = 'Ford';
COMMIT;
UPDATE MY_DATA SET SALARY = 15000 WHERE SALARY <= 15000;
DROP TABLE MY_DATA;

-- EMP 테이블과 같은 구조와 같은 내용의 테이블 EMP01을 생성(테이블이 있을시 
    --제거한 후)하고, 모든 사원의 부서번호를 30번으로 수정합니다.
DROP TABLE EMP01;
CREATE TABLE EMP01 AS SELECT * FROM EMP;
SELECT * FROM EMP01;
UPDATE EMP01 SET DEPTNO = 30;

-- EMP01테이블의 모든 사원의 급여를 10% 인상시키는 UPDATE문을 작성
UPDATE EMP01 SET SAL = SAL*1.1;

-- 급여가 3000이상인 사원만 급여를 10%인상
UPDATE EMP01 SET SAL = SAL*1.1 WHERE SAL >= 3000;

-- EMP01테이블에서 ‘DALLAS’에서 근무하는 직원들의 연봉을 1000인상
UPDATE EMP01 SET SAL = SAL+1000 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');

-- SCOTT사원의 부서번호는 20번으로, 직급은 MANAGER로 한꺼번에 수정
UPDATE EMP01 SET DEPTNO = 20, JOB = 'MANAGER' WHERE ENAME = 'SCOTT';

-- 부서명이 SALES인 사원을 모두 삭제하는 SQL작성
DELETE FROM EMP01 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');

-- 사원명이 ‘FORD’인 사원을 삭제하는 SQL 작성
DELETE FROM EMP01 WHERE ENAME = 'FORD';

-- SAM01 테이블에서 JOB이 NULL인 사원을 삭제하시오
DELETE FROM SAM01 WHERE JOB IS NULL;

-- SAM01테이블에서 ENAME이 ORANGE인 사원을 삭제하시오
DELETE FROM SAM01 WHERE ENAME = 'ORANGE';

-- ★ ★ ★ 제약조건
-- (1) FRIMARY KEY : 테이블의 각 행을 유일한 값으로 식별하기 위한 필드
-- (2) FOREIGN KEY : 테이불의 열이 다른 테이블의 열을 참조
-- (3) NOT NULL    : NULL을 포함하지 않음
-- (4) UNIQUE      : 모든 행의 값이 유일, NULL값은 허용(NULL은 여러개 입력 가능)
-- (5) CHECK(조건)  : 해당 조건을 만족, NULL값은 허용
-- DEFAULT: 기본값 설정(해당 열의 데이터 입력을 하지 않으면 NULL이 들어가나 DEFAULT 값으로 설정)

    -- DEPT1 & EMP1 테이블 생성
DROP TABLE EMP1;
DROP TABLE DEPT1;
CREATE TABLE DEPT1 (
    DEPTNO  NUMBER(2) PRIMARY KEY,
    DNAME   VARCHAR2(14) NOT NULL UNIQUE,
    LOC     VARCHAR2(13) NOT NULL
);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT1';
DROP TABLE DEPT1;
CREATE TABLE DEPT1 (
    DEPTNO  NUMBER(2) CONSTRAINT DEPT_PK PRIMARY KEY,
    DNAME   VARCHAR2(14) CONSTRAINT DEPT_U NOT NULL UNIQUE,
    LOC     VARCHAR2(13) CONSTRAINT DEPT_LOC NOT NULL
);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT1';
DROP TABLE DEPT1;
CREATE TABLE DEPT1 (
    DEPTNO  NUMBER(2),
    DNAME   VARCHAR2(14) NOT NULL,
    LOC     VARCHAR2(13) NOT NULL,
    CONSTRAINT DEPTNO_P PRIMARY KEY(DEPTNO),
    CONSTRAINT DNAME_U UNIQUE(DNAME)
);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT1';
SELECT * FROM DEPT1;
SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'DEPT1';

DROP TABLE EMP1;
CREATE TABLE EMP1 (
    EMPNO   NUMBER(4) PRIMARY KEY,
    ENAME   VARCHAR2(10) NOT NULL,
    JOB     VARCHAR2(9) NOT NULL,
    MGR     NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL     NUMBER(7,2) CHECK (SAL>0),
    COMM    NUMBER(7,2),
    DEPTNO  NUMBER(2) REFERENCES DEPT1(DEPTNO)
);
DROP TABLE EMP1;
CREATE TABLE EMP1 (
    EMPNO   NUMBER(4),
    ENAME   VARCHAR2(10) NOT NULL,
    JOB     VARCHAR2(9) NOT NULL,
    MGR     NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL     NUMBER(7,2),
    COMM    NUMBER(7,2),
    DEPTNO  NUMBER(2),
    PRIMARY KEY(EMPNO),
    CHECK (SAL>0),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO)
);
SELECT * FROM EMP1;
SELECT * FROM DEPT1;

INSERT INTO DEPT1 SELECT * FROM DEPT;
INSERT INTO DEPT1 (DEPTNO, DNAME, LOC)
    VALUES (40, 'IT', 'SEOUL'); -- 에러
INSERT INTO DEPT1 (DEPTNO, DNAME, LOC)
    VALUES (50, 'IT', 'SEOUL');
INSERT INTO DEPT1 VALUES (60, 'IT', 'PUSAN'); -- 에러
INSERT INTO DEPT1 VALUES (60, 'PLANNING', 'PUSAN');
INSERT INTO DEPT1 (DEPTNO, DNAME) VALUES (70, 'CS'); -- 에러
INSERT INTO DEPT1 (DEPTNO, DNAME, LOC) VALUES (70, 'CS', 'GANGNAM');
SELECT * FROM DEPT1;

INSERT INTO EMP1 (EMPNO, ENAME, JOB) VALUES (1001, 'HONG', 'MANAGER'); -- SAL, DEPTNO에 NULL 가능
SELECT * FROM EMP1;
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL) VALUES (1002, 'HONG', 'MANAGER', 0); -- 에러
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL) VALUES (1002, 'HONG', 'MANAGER', 10000);
INSERT INTO EMP1 VALUES (1003, 'KIM', 'MANAGER', NULL, NULL, NULL, NULL, 90); -- 에러
INSERT INTO EMP1 VALUES (1003, 'KIM', 'MANAGER', NULL, NULL, NULL, NULL, 70);
SELECT * FROM EMP1;

SELECT * FROM BOOK;
DROP TABLE BOOK;

CREATE TABLE BOOKCATEGORY (
    CATEGORYCODE NUMBER(3) PRIMARY KEY,
    CATEGORYNAME VARCHAR2(20) UNIQUE,
    OFFICE_LOC   VARCHAR2(20) NOT NULL
);
SELECT * FROM BOOKCATEGORY;

CREATE TABLE BOOK (
    CATEGORYCODE NUMBER(3) NOT NULL REFERENCES BOOKCATEGORY(CATEGORYCODE),
    bookNo      VARCHAR2(20)PRIMARY KEY,
    bookNAME    VARCHAR2(30),
    PUBLISHER   VARCHAR2(20),
    PUBYEAR     NUMBER(4) DEFAULT EXTRACT(YEAR FROM SYSDATE)
);
SELECT * FROM BOOK;

INSERT INTO BOOKCATEGORY VALUES (100, '철학', '3층 인문실');
INSERT INTO BOOKCATEGORY VALUES (200, '인문', '3층 인문실');
INSERT INTO BOOKCATEGORY VALUES (300, '자연과학', '4층 과학실');
INSERT INTO BOOKCATEGORY VALUES (400, 'IT', '4층 과학실');
SELECT * FROM BOOKCATEGORY;

INSERT INTO BOOK VALUES (100, '100A01', '철학자의 삶', '이젠출판', 2021);
INSERT INTO BOOK (CATEGORYCODE, bookNo, bookNAME, PUBLISHER) VALUES (400, '400A01', '이것이DB다', '다음출판');
SELECT * FROM BOOK;

SELECT BOOKNO 책번호, BOOKNAME 책이름, PUBLISHER 출판사, PUBYEAR 출판년도, CATEGORYNAME 책분류, OFFICE_LOC 사무실
    FROM BOOK B, BOOKCATEGORY C
    WHERE B.CATEGORYCODE = C.CATEGORYCODE;
    
-- 데이터 삭제시
SELECT * FROM BOOKCATEGORY; -- 100, 200, 300, 400
SELECT * FROM BOOK; -- 100, 400
DELETE FROM BOOKCATEGORY WHERE CATEGORYCODE = 100; -- CHILD에서 참조하고 있는 데이터
DELETE FROM BOOK WHERE CATEGORYCODE = 100;
DELETE FROM BOOKCATEGORY WHERE CATEGORYCODE = 100; -- CHILD에서 참조하는 데이터가 없으면 삭제 가능
SELECT * FROM BOOKCATEGORY; -- 200, 300, 400
SELECT * FROM BOOK; -- 400
DELETE FROM BOOKCATEGORY WHERE CATEGORYCODE IN (200, 300);
DELETE FROM BOOK;
SELECT * FROM BOOK;
COMMIT;
DELETE FROM BOOKCATEGORY; -- CHILD 테이블에 참조하는 테이터가 없을 경우 DELETE 가능
DROP TABLE BOOK;
DROP TABLE BOOKCATEGORY;
DROP TABLE BOOKCATEGORY CASCADE CONSTRAINTS; -- 쓰면 안됨

DROP TABLE STUDENT;
DROP TABLE MAJOR;

CREATE TABLE MAJOR (
    MAJOR_CODE NUMBER(3) PRIMARY KEY,
    MAJOR_NAME VARCHAR2(50),
    MAJOR_OFFICE_LOC VARCHAR2(50)
);

CREATE TABLE STUDENT (
    STUDENT_CODE NUMBER(10) PRIMARY KEY,
    STUDENT_NAME VARCHAR2(50),
    SCORE        NUMBER(3) CHECK (0 <= SCORE AND SCORE <= 100),
    MAJOR_CODE   NUMBER(2) REFERENCES MAJOR(MAJOR_CODE)
);

INSERT INTO MAJOR VALUES (1, '컴퓨터공학', 'A101호');
INSERT INTO MAJOR VALUES (2, '빅데이터', 'A102호');

SELECT * FROM MAJOR;

INSERT INTO STUDENT VALUES (101, '홍길동', 99, 1);
INSERT INTO STUDENT VALUES (102, '신길동', 100, 2);

SELECT * FROM STUDENT;

SELECT STUDENT_CODE 학번, STUDENT_NAME 이름, SCORE 점수, S.MAJOR_CODE 학과코드, MAJOR_NAME 학과명, MAJOR_OFFICE_LOC 학과사무실
    FROM MAJOR M, STUDENT S
    WHERE M.MAJOR_CODE = S.MAJOR_CODE;
    
-- ★ DCL (사용자계정생성, 사용자권한부여, 권한박탈, 사용자계정삭제)
CREATE USER scott2 IDENTIFIED BY tiger; --  scott2 계정 생성
-- 권한부여(세션부여)
GRANT CREATE SESSION TO SCOTT2;
-- 권한부여(TABLE, VIEW 생성)
CREATE ROLE ROLEex;
GRANT CREATE TABLE, CREATE VIEW TO ROLEex;
GRANT ROLEex TO SCOTT2;
-- 권한부여(EMP 테이블의 모든 권한)
GRANT ALL ON EMP TO SCOTT2;
-- 권한부여(DEPT 테이블의 SELECT 권한)
GRANT SELECT ON DEPT TO SCOTT2;
-- 권한박탈(DEPT 테이블, EMP 테이블 권한 - 계정 접속 해제 후 실행 추천)
REVOKE ALL ON EMP FROM SCOTT2;
REVOKE SELECT ON DEPT FROM SCOTT2;
-- 사용자 계정 삭제(접속중에는 삭제 불가)
DROP USER SCOTT2 CASCADE;